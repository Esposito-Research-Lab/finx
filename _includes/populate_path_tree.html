{% comment %}
We go through and create the tree we'll want for walking our path structure
The way we have to do this can be shown by example. Say we have:

root/
root/page.html
root/subpage/subpage.html
root/subpage/filename.html
root/uppage/file2.html
root/zoop.html

We'd like the tree for this to look like:

[
    depth=1, url=root/, name=root, page=nil
    children = [
        [ depth=2, url=root/page.html, name=page, page=root/page.html, children=[] ],
        [
            depth=2, url=root/subpage, name=subpage, page=nil,
            children=[
                [ depth=3, url=root/subpage/subpage.html, name=subpage, page=root/subpage/subpage.html, children=[] ],
                [ depth=3, url=root/subpage/filename.html, name=filename, page=root/subpage/filename.html, children=[] ]
                ...
            ]
        ],
        ...
    ]
]

That is a tree we could easily traverse, rather than the nasty mess we currently have...

Here's a proposed algorithm for that
stack = []
We start at root. We set some parent variables:
    p_depth=1
    p_url=root
    p_name=root
    p_page=nil
    p_children=[]
    stack = []
Then we go to root/page.html. We find new variable values:
    depth=2
    name=page
    page=root/page.html
    children=[]
Since root/page.html is a child of p_url, don't do anything (since our children list isn't built),
    but assign these variable values to prev_[varname]
Next we go to root/subpage/subpage.html:
    depth=3
    name=subpage
    page=root/subpage/subpage.html
    children=[]
This is _not_ a child of prev_url, so that node is closed and we can add it to p_children
    p_children = [[prev_depth, prev_name, prev_page, prev_children]]
Then we note that (depth - p_depth) > 1 so we need to set up the requisite intermediate nodes.
Before doing this (and anytime we recurse into the tree) we need to push the p_* data onto our stack:
    stack = [ [p_*], [] ]
Now we allocate a stack to put the intermediate nodes on
    e_stack = []
Then we fill this do this by iterating over the number of depth skips and dropping another level each time we do this.
That is, at each step we create the empty node:
    e_depth=(depth - i)
    e_url=(--extract url--)
    e_name=(--extract name--)
    e_page=nil
    e_children=[]
Then we push that onto the e_stack: (this puts it in _reverse_ order from how we need it)
    e_stack = [..., [empty_node] ]
Finally we push all but the last of these onto the recursion stackby iterating over each of these in reverse.
This gives us:
    stack = [ [deepest_empty_node], [previous_stacks] ]
On the last of these we set the p_ parameters appropriately to continue wthe basic algorithm.
Now, as this _is_ a child of the current p_url don't do anything further and continue on.
We're now at root/subpage/filename.html:
    depth=3
    name=filename
    page=root/subpage/filename.html
    children=[]
This is _not_ a child of prev_url and the two only differ in the last element (of prev_url) so we just push the prev_* data onto the p_children
Nothing else to do, so we continue onto root/uppage/file2.html:
    depth=3
    name=file2
    page=root/uppage/file2.html
    children=[]
This is _not_ a child of prev_url, and the two differ two elements up in the tree, so we close off two nodes, then continue on
Etc.
At the end, close off any open nodes (by walking the rest of the stack) and our tree is complete

{% endcomment %}

{% assign node_stack = ""|split:"" %}

{% assign d_split = parent | split:"/" %}
{% assign parent_depth = d_split | size %}
{% assign parent_page = nil %}
{% assign parent_name = d_split | last | split:"." | first %}
{% assign parent_directory = "" %}
{% for d in d_split limit:(d_split|size|minus:1)) %}
    {% assign parent_directory = parent_directory | append:"/" | append:d %}
{% endfor %}
{% assign parent_url = parent %}
{% assign parent_children = ""|split:"" %}

{% assign prev_depth = parent_depth %}
{% assign prev_page = parent_page %}
{% assign prev_name = parent_name %}
{% assign prev_directory = parent_directory %}
{% assign prev_url = parent_url %}
{% assign prev_children = parent_children %}

{% assign page_set = page_set | sort %}
{% for page in page_set %}
    {% comment %}
        We first determine the parameters for the given page
    {% endcomment %}
    {% assign d_split = page.url | split:"/" %}
    {% assign depth = d_split | size %}
    {% if (d_split | last) contains "." %}
        {% assign depth = depth | minus:1 %}
    {% endif %}
    {% assign name = d_split | last | split:"." | first %}
    {% assign directory = "" %}
    {% for d in d_split limit:(d_split|size|minus:1)) %}
        {% assign directory = directory | append:"/" | append:d %}
    {% endfor %}
    {% assign url = page.url %}
    {% assign children = ""|split:"" %}

    {% comment %}
        Now we check if this is in the same branch as the previous element we looked at
    {% endcomment %}
    {% if url contains prev_parent_url %}
        {% comment %} means we're still in the same tree {% endcomment %}
        {% if depth > prev_depth %}
            {% comment %}
                Means we need to drop down some number of levels:
                    we put the current parent_* data on the stack
            {% endcomment %}

            {% assign parent_node = ""|split:"" %}
            {% assign parent_node = parent_node|push:parent_depth %}
            {% assign parent_node = parent_node|push:parent_page %}
            {% assign parent_node = parent_node|push:parent_name %}
            {% assign parent_node = parent_node|push:parent_directory %}
            {% assign parent_node = parent_node|push:parent_url %}
            {% assign parent_node = parent_node|push:parent_children %}

            {% assign _substack = ""|split:"" %}
            {% assign _substack = _substack|push:parent_node %}
            {% assign _substack = _substack|push: (node_stack[1]|plus:1) %}
            {% assign _substack = _substack|push:node_stack %}
            {% assign node_stack = _substack %}

            {% comment %}
                AT THIS POINT WE NEED TO HANDLE INSERTING LIKE THOSE THINGS WHERE WE JUMP MULTIPLE ELEMENTS
            {% endcomment %}

            {% assign parent_depth = depth %}
            {% assign parent_page = page %}
            {% assign parent_name = name %}
            {% assign parent_directory = directory %}
            {% assign parent_url = url %}
            {% assign parent_children = children %}
        {% else %}
            {% comment %}
                Means we're at the same level (otherwise the first test would fail) so we just push the prev_* data onto the parent_children
            {% endcomment %}
            {% assign node = ""|split:"" %}
            {% assign node = node|push:prev_depth %}
            {% assign node = node|push:prev_page %}
            {% assign node = node|push:prev_name %}
            {% assign node = node|push:prev_directory %}
            {% assign node = node|push:prev_url %}
            {% assign node = node|push:prev_children %}
            {% assign parent_children = parent_children|push:node %}
        {% endif %}

    {% else %}
        {% comment %}
            This means at _some_ point we jumped up a branch. We need to figure out where we made this jump.
            Once we have that, we can walk the rest of the way back up our tree, closing as necessary
        {% endcomment %}

        {% assign alignment = 0 %}
        {% if prev_depth > depth %}
            {% assign bounds = depth %}
        {% else %}
            {% assign bounds = prev_depth %}
        {% endif %}
        {% assign prev_split = prev_url | split:"/" %}
        {% assign cur_split = url | split:"/" %}
        {% for i in (0..bounds) %}
            {% assign new = cur_split[i] %}
            {% assign old = prev_split[i] %}
            {% if new != old %}
                {% assign need_to_close = prev_depth | minus:i %}
                {% break %}
            {% endif %}
        {% endfor %}
        {% for i in (1..need_to_close) %}
            {% comment %}
                To close a node, we stick the current node into the parent_children
                Then we pop a node off the node_stack, set all of the parent_* values to the standard values and
                then assign all of the parent_node to the parent_* names
            {% endcomment %}
            {% assign node = ""|split:"" %}
            {% assign node = node|push:prev_depth %}
            {% assign node = node|push:prev_page %}
            {% assign node = node|push:prev_name %}
            {% assign node = node|push:prev_directory %}
            {% assign node = node|push:prev_url %}
            {% assign node = node|push:prev_children %}
            {% assign parent_children = parent_children|push:node %}
            {% assign node = node_stack[0] %}
            {% assign node_stack = node_stack[2] %}
            {% assign prev_depth = node[0] %}
            {% assign prev_page = node[1] %}
            {% assign prev_name = node[2] %}
            {% assign prev_directory = node[3] %}
            {% assign prev_url = node[4] %}
            {% assign prev_children = node[5] %}
        {% endfor %}
    {% endif %}

    {% comment %}
        After every single step we also make it so that the current data is the prev_* data so that the loop may continue
    {% endcomment %}

    {% assign prev_depth = depth %}
    {% assign prev_page = page %}
    {% assign prev_name = name %}
    {% assign prev_directory = directory %}
    {% assign prev_url = url %}
    {% assign prev_children = children %}

{% endfor %}